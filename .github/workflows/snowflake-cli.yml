name: Snowflake Model Auto-Sync + Release

on:
  repository_dispatch:
    types: [model_sync]
  push:
    branches:
      - main
  workflow_dispatch:    

permissions:
  contents: write  # Required to push files and create releases

jobs:
  sync-snowflake-model:
    runs-on: ubuntu-latest
    name: Fetch, Commit & Release Model from Snowflake

    env:
      SNOWFLAKE_CONNECTIONS_DEFAULT_ACCOUNT: ${{ secrets.SNOWFLAKE_ACCOUNT }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_USER: ${{ secrets.SNOWFLAKE_USER }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_PASSWORD: ${{ secrets.SNOWFLAKE_PASSWORD }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_ROLE: ${{ secrets.SNOWFLAKE_ROLE }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_WAREHOUSE: ${{ secrets.SNOWFLAKE_WAREHOUSE }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE: ${{ github.event.client_payload.database || secrets.SNOWFLAKE_DATABASE }}
      SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA: ${{ github.event.client_payload.schema || secrets.SNOWFLAKE_SCHEMA }}

    steps:
      # 1Ô∏è‚É£ Checkout repository
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      # 2Ô∏è‚É£ Install Snowflake CLI (modern v3) and jq
      - name: Install Snowflake CLI (v3) and jq
        shell: bash
        run: |
          echo "üêç Installing modern Snowflake CLI..."
          python3 -m pip install --upgrade pip
          pip install --user --upgrade "snowflake-cli>=3.10.0"
          sudo apt-get install -y jq
          echo 'export PATH=$HOME/.local/bin:$PATH' >> $GITHUB_ENV
          source $GITHUB_ENV
          snow --version

      # 3Ô∏è‚É£ Configure Snowflake connection
      - name: Configure Snowflake connection
        shell: bash
        run: |
          echo "üß© Creating ~/.snowflake/config.toml..."
          mkdir -p ~/.snowflake
          {
            echo "[connections.default]"
            echo "account = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_ACCOUNT}\""
            echo "user = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_USER}\""
            echo "password = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_PASSWORD}\""
            echo "role = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_ROLE}\""
            echo "warehouse = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_WAREHOUSE}\""
            echo "database = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE}\""
            echo "schema = \"${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA}\""
          } > ~/.snowflake/config.toml

          chmod 600 ~/.snowflake/config.toml
          echo "‚úÖ Config file created and secured."

      # 4Ô∏è‚É£ Verify Snowflake connection
      - name: Verify Snowflake connection
        shell: bash
        run: |
          echo "üîé Testing Snowflake connection..."
          snow connection list
          snow sql -q "SELECT CURRENT_USER(), CURRENT_ROLE(), CURRENT_DATABASE(), CURRENT_SCHEMA();" --format CSV

      # 5Ô∏è‚É£ Trigger ML pipeline in Snowflake
      - name: Trigger Snowflake ML pipeline
        shell: bash
        run: |
          echo "üöÄ Executing Snowflake ML pipeline..."
          snow sql -q "
            USE WAREHOUSE ${SNOWFLAKE_CONNECTIONS_DEFAULT_WAREHOUSE};
            USE DATABASE ${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE};
            USE SCHEMA ${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA};
            EXECUTE TASK TASK_1_DATA_INGESTION;
          "
          echo "‚úÖ Pipeline triggered successfully."

      # 6Ô∏è‚É£ Wait for model training completion
      - name: Wait for TASK_3_MODEL_TRAINING success
        shell: bash
        run: |
          echo "‚è≥ Waiting for TASK_3_MODEL_TRAINING success..."
          ATTEMPTS=20
          SLEEP_SEC=30
          i=1
          while [ $i -le $ATTEMPTS ]; do
            count=$(snow sql --format csv -q "
              SELECT COUNT(*) FROM TABLE(
                INFORMATION_SCHEMA.TASK_HISTORY(
                  SCHEDULED_TIME_RANGE_START => DATEADD('minute', -60, CURRENT_TIMESTAMP())
                )
              )
              WHERE NAME = 'TASK_3_MODEL_TRAINING' AND STATE = 'SUCCEEDED';
            " | tail -n +2 | cut -d',' -f1)
            echo "üîé success_count(last 60m) = ${count}"
            if [ "${count}" != "0" ]; then
              echo "‚úÖ Training task succeeded recently."
              break
            fi
            i=$((i+1))
            echo "‚Ä¶not done yet, sleeping ${SLEEP_SEC}s"
            sleep ${SLEEP_SEC}
          done
          if [ "${count}" = "0" ]; then
            echo "‚ùå Training task did not report success in time."
            exit 1
          fi

      # 7Ô∏è‚É£ List ONNX models in stage
      - name: List ONNX models in Snowflake stage
        shell: bash
        run: |
          echo "üìú Listing ONNX models..."
          snow sql -q "
            USE DATABASE ${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE};
            USE SCHEMA ${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA};
            LIST @${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE}.${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA}.ML_MODELS_STAGE PATTERN='.*.onnx';
          " --format table

      # 8Ô∏è‚É£ Download newest ONNX model and push to repo + release
      - name: Download latest ONNX file, commit, and release
        env:
          GH_TOKEN: ${{ github.token }}
        shell: bash
        run: |
          echo "üì• Fetching latest ONNX file..."
          mkdir -p staged_models

          json_out=$(snow sql -q "
            USE DATABASE ${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE};
            USE SCHEMA ${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA};
            LIST @${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE}.${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA}.ML_MODELS_STAGE PATTERN='.*.onnx';
          " --format json)

          latest_file=$(echo "$json_out" | jq -r '
            flatten
            | map(select(.name? != null))
            | sort_by(
                ( .last_modified
                  | sub(", "; " ")
                  | strptime("%a %d %b %Y %H:%M:%S GMT")
                  | mktime )
              )
            | reverse
            | .[0].name
          ')

          if [ -z "$latest_file" ] || [ "$latest_file" == "null" ]; then
            echo "‚ùå No ONNX files found!"
            echo "$json_out" | head -n 40
            exit 1
          fi

          echo "‚úÖ Latest file: $latest_file"
          clean_file=${latest_file#ml_models_stage/}

          echo "üß© Downloading model..."
          snow sql -q "GET @${SNOWFLAKE_CONNECTIONS_DEFAULT_DATABASE}.${SNOWFLAKE_CONNECTIONS_DEFAULT_SCHEMA}.ML_MODELS_STAGE/$clean_file file://staged_models/"
          echo "‚úÖ Model downloaded to staged_models/$clean_file"

          # Commit model to repo
          git config user.name "github-actions"
          git config user.email "actions@github.com"
          git add staged_models/
          git commit -m "Auto-sync ONNX model from Snowflake stage ($clean_file)" || echo "No new model changes"

          CURRENT_BRANCH="${GITHUB_REF_NAME}"
          echo "üîÄ Current branch is ${CURRENT_BRANCH}"
          git pull --rebase origin "${CURRENT_BRANCH}" || true
          git push origin "${CURRENT_BRANCH}"

          # Create a release with the latest ONNX model
          RELEASE_TAG="model-$(date +'%Y%m%d-%H%M%S')"
          echo "üì¶ Creating release: $RELEASE_TAG"
          
          # Get the downloaded model file name
          LATEST_MODEL_FILE=$(basename "$clean_file")
          
          # Make sure it exists
          if [ ! -f "staged_models/$LATEST_MODEL_FILE" ]; then
            echo "‚ùå Model file not found at staged_models/$LATEST_MODEL_FILE"
            exit 1
          fi
          
          # Create GitHub release with only this file
          gh release create "$RELEASE_TAG" "staged_models/$LATEST_MODEL_FILE" \
            --title "Model Release ($RELEASE_TAG)" \
            --notes "Latest trained model automatically synced from Snowflake." \
            --latest


      # 9Ô∏è‚É£ Summary
      - name: Summary
        run: |
          echo "‚úÖ Model committed to repo and released successfully!"
